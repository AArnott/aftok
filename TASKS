General:
  * Convert SQLite code to use Persistent

User Interface:
  * Login
    * Evaluate OAuth options
  * Invite
    * Record who invited a participant.
    * When a new participant is invited to the project, allow them to create an account.
  * Profile
  * Timeline - Yours
    * Log Start
    * Log Stop
    * Amend Event
      * Amend operations targeting events older than <commit_delay hours> fail.
      * Future work - garnish/reimburse based approach? 
  * Payouts
    * History of payouts (read from blockchain?)
    * Projected payout given current data
    * BTC address alias chains (in case new payouts should go elsewhere)
  * Voting
    * List Proposals
    * Create Proposal
      * Options to be considered
      * Closing date
    * Vote
  * Resource Pooling
    * Create Resource Pool
      * Describe resource need
      * Base resource award set by socialized vote?
        * Voting on continuous values?
      * Set resource contribution timeline
      * Solicit/Suggest resource acquisition designee (& vote)
    * Escrow of resource acquisition contributions. 
      * Resource award bidding?
      * In case of oversubscription, award is reduced by a function of the oversubscription amount.
      * "Test Oversubscription" functionality.

Quixotic Service
  * Read blockchain transactions; when a payment is observed, distribute it to participants.
  * Adjust work index reader to only read work index entries older than <commit_delay hours>. 
  * Tabulate votes & randomly pick from weighted distribution.
  * Resource pool awarding
